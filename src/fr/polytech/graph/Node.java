package fr.polytech.graph;

import fr.polytech.exception.EdgeAlreadyExistsException;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

/*
An object to represent a node.
A node has a name, a color and two lists of edges objects, one for incoming ones and one for outgoing ones.
The color attribute is inherited from the Colored class.
*/
public class Node extends Colored
{
    private final String name;
    private final List<Edge> incomingEdges;
    private List<Edge> outgoingEdges;

    /*
    Builds a node from a color and a name.
     */
    public Node(Color color, String name)
    {
        super(color);
        this.name = name;
        this.outgoingEdges = new ArrayList<>();
        this.incomingEdges = new ArrayList<>();
    }

    /*
    Builds a node from a color, a name and a list of edges.
     */
    public Node(Color color, String name, List<Edge> edges)
    {
        this(color, name);
        this.outgoingEdges = edges;
    }

    /*
    Add an outgoing edge.
    If an outgoing edge to the same node that the one contained in the edge in parameter exists, an EdgeAlreadyExistsException is thrown.
    Else, the edge is added normally, and is also added to the incoming edges of the other node.
     */
    public void addOutgoingEdge(Edge edge) throws EdgeAlreadyExistsException
    {
        if(getNextNodeByName(edge.getEnd()
                .getName())
                .isPresent())
        {
            throw new EdgeAlreadyExistsException();
        }

        outgoingEdges.add(edge);
        edge.getEnd().getIncomingEdges().add(edge);
    }

    /*
    Looks for an outgoing node having the named passed in parameter. Returns the node if found, wrapped in an Optional<Node>.
    If no node matches the given name, returns Optional::EMPTY.
     */
    public Optional<Node> getNextNodeByName(String name)
    {
        return outgoingEdges
                .stream()
                .map(Edge::getEnd)
                .filter(end -> end.getName().equals(name))
                .findAny();
    }

    /*
    Returns the node's name.
     */
    public String getName()
    {
        return name;
    }

    /*
    Returns the list of outgoing edges.
     */
    public List<Edge> getOutgoingEdges()
    {
        return outgoingEdges;
    }

    /*
    Returns the list of incoming edges.
     */
    public List<Edge> getIncomingEdges()
    {
        return incomingEdges;
    }

    /*
    Changes the color of the node.
     */
    public void setColor(Color color)
    {
        this.color = color;
    }

    /*
    Conventional equals function.
     */
    @Override
    public boolean equals(Object o)
    {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Node node = (Node) o;
        return name.equals(node.name) && outgoingEdges.equals(node.outgoingEdges);
    }

    /*
    Autogenerated hashCode function.
     */
    @Override
    public int hashCode()
    {
        return Objects.hash(name, outgoingEdges);
    }

    /*
    Autogenerated toString function.
     */
    @Override
    public String toString()
    {
        return "Node{" +
                "color=" + color +
                ", name='" + name + '\'' +
                ", edges=" + outgoingEdges +
                '}';
    }
}
